# generate grackle_float.h AND auto_general.c
# ===========================================

# TODO: if they exist, delete ${CMAKE_CURRENT_SOURCE_DIR}/grackle_float.h AND
# ${CMAKE_CURRENT_SOURCE_DIR}/auto_general.c
# -> this probably isn't necessary, but it certainly makes things less confusing

# first, declare recipe for generating grackle_float.h:
if (GRACKLE_USE_DOUBLE)
  set(GRACKLE_FLOAT_MACRO "GRACKLE_FLOAT_8")
else()
  set(GRACKLE_FLOAT_MACRO "GRACKLE_FLOAT_4")
endif()
configure_file(grackle_float.h.in
  ${GRACKLE_GENRATED_PUBLIC_HEADERS}/grackle_float.h @ONLY)

# next, declare recipe for generating auto_general.c:

# fetch necessary version information via query-version.py script
# -> GIT_BRANCH and GIT_REVISION hold sensible vals when git isn't installed
# -> VERSION_NUM may hold more information than Grackle_VERSION (e.g. like the
#    "dev" suffix)

set(_query_version "${CMAKE_CURRENT_SOURCE_DIR}/../../config/query_version.py")
function(query_version option OUTVAR)
  execute_process(
      COMMAND ${_query_version} ${option}
      RESULT_VARIABLE RSLT OUTPUT_VARIABLE OUT
      OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if(RSLT)
    message(FATAL_ERROR "Call to `${_query_version} ${option}` failed")
  endif()
  set(${OUTVAR} ${OUT} PARENT_SCOPE)
endfunction()

query_version(show-version VERSION_NUM)
query_version(git-branch GIT_BRANCH)
query_version(git-revision GIT_REVISION)

# in the original build-system, the following string also included things like:
# include-args, linking flags, macro definitions, all other compiler flags...
string(REPLACE "\n" "\\n" SHOW_FLAGS_STR "
  CC = ${CMAKE_C_COMPILER}
  FC = ${CMAKE_Fortran_COMPILER}
  LD = ${CMAKE_LINKER}
")

string(REPLACE "\n" "\\n" SHOW_CONFIG_STR "
   Built with CMake

   GRACKLE_USE_DOUBLE                  : ${GRACKLE_USE_DOUBLE}
   GRACKLE_USE_OPENMP                  : ${GRACKLE_USE_OPENMP}
   BUILD_TYPE                          : ${CMAKE_BUILD_TYPE}
")

configure_file(auto_general.c.in auto_general.c @ONLY)

# Declare the main target
# =======================

# NOTE: A subtle/silent bug can occur, when a previous build was installed in a
# standard system location, like /usr/local, and the auto-generated header(s)
# are not explicitly listed out (i.e. they're instead included in a list with
# other files). In that scenario, CMake doesn't realize it needs to generate
# the header(s) and the compiler thinks everything is fine because it can find
# the version of the header generated in an older version of the build in the
# standard system search path
add_library(Grackle_Grackle

  # C source files
  calculate_cooling_time.c
  calculate_dust_temperature.c
  calculate_gamma.c
  calculate_pressure.c
  calculate_temperature.c
  dynamic_api.c
  grackle_units.c
  index_helper.c
  initialize_chemistry_data.c
  initialize_cloudy_data.c
  initialize_rates.c
  initialize_UVbackground_data.c
  rate_functions.c
  set_default_chemistry_parameters.c
  solve_chemistry.c
  update_UVbackground_rates.c
  calculate_cooling_time.c
  calculate_dust_temperature.c
  calculate_gamma.c
  calculate_pressure.c
  calculate_temperature.c
  dynamic_api.c
  grackle_units.c
  index_helper.c
  initialize_chemistry_data.c
  initialize_cloudy_data.c
  initialize_rates.c
  initialize_UVbackground_data.c
  rate_functions.c
  set_default_chemistry_parameters.c
  solve_chemistry.c
  update_UVbackground_rates.c
  calculate_cooling_time.c
  calculate_dust_temperature.c
  calculate_gamma.c
  calculate_pressure.c
  calculate_temperature.c
  dynamic_api.c
  grackle_units.c
  index_helper.c
  initialize_chemistry_data.c
  initialize_cloudy_data.c
  initialize_rates.c
  initialize_UVbackground_data.c
  rate_functions.c
  set_default_chemistry_parameters.c
  solve_chemistry.c
  update_UVbackground_rates.c
  utils.c

  # Fortran Source Files
  calc_tdust_1d_g.F
  calc_tdust_3d_g.F
  calc_temp1d_cloudy_g.F
  calc_temp_cloudy_g.F
  cool1d_cloudy_g.F
  cool1d_cloudy_old_tables_g.F
  cool1d_multi_g.F
  cool_multi_time_g.F
  interpolators_g.F
  solve_rate_cool_g.F

  # auto-generated source files
  ${CMAKE_CURRENT_BINARY_DIR}/auto_general.c

  # explicitly list the autogenerated headers (to ensure that CMake identifies
  # it as a dependency)
  ${GRACKLE_GENRATED_PUBLIC_HEADERS}/grackle_float.h
)

# A downstream application built with CMake generally has 2 inclusion
# approaches (ways that they can make use of this build):
#    1. they can build Grackle as part of the downstream build.
#       - in this case, the downstream build calls add_subdirectory on the top
#         level directory of Grackle and they can access the targets defined in
#         this file.
#    2. they can use the installed library
#       - in this case, the downstream build will get access to the targets
#         defined in a special CMake export-file created during installation
#
# We take some care to make these approaches as interchangable as possible for
# downstream build. To that end, we take 2 primary steps:
#
# - we name the main target Grackle_Grackle, rather than just [Gg]rackle to
#   minimize the chance for name-collisions of targets created by the build of
#   the downstream application (this is relevant for approach #1)
#
# - Following existing conventions, the downstream project should access the
#   target called Grackle::Grackle. We make use of a namespace to follow
#   convention... (they are more useful if we built multiple targets as part of
#   the build)
add_library(Grackle::Grackle ALIAS Grackle_Grackle) # for inclusion appraoch #1

# the logic diverges a little when naming the library
if (BUILD_SHARED_LIBS)
  # Because Grackle's API is not currently suited for ABI-compatability, we
  # take special steps when compiling it as a shared library (to reduce the
  # chance that an application linked against one version will try to load a
  # newer, incompatible version of the library)
  # - we take a page out of the existing build-system and libtool
  # - essentially, we will (i) encode the version in core-name of the library
  #   and (ii) make a symbolic link called libgrackle.so to the the library
  # - separate instructions are needed to make this link in build-directory
  #   and in the installation directory
  set(GRACKLE_LIB_OUTPUT_NAME "grackle-${VERSION_NUM}")
  add_custom_target(buildtree_link_target
    ALL COMMAND ${CMAKE_COMMAND} -E create_symlink
      $<TARGET_FILE:Grackle_Grackle>
      $<TARGET_FILE_DIR:Grackle_Grackle>/libgrackle.so)
else()
  set(GRACKLE_LIB_OUTPUT_NAME "grackle") # resulting lib is named libgrackle.a
endif()

set_target_properties(Grackle_Grackle PROPERTIES
  OUTPUT_NAME ${GRACKLE_LIB_OUTPUT_NAME} # <- ensure library is properly named
  # specify target name made available that is made visible in inclusion
  # approach #2. The namespace-prefix of this target, "Grackle::", is declared
  # down below in install(EXPORT ...)
  EXPORT_NAME Grackle
)

target_include_directories(Grackle_Grackle
  # specify where to search for generated and ordinary headers when building
  # grackle AND when linking against grackle under inclusion approach #1
  # -> while it may seem unnecessary to specify the ordinary headers' directory
  #    while building grackle, it's necessary to compile auto_general.c
  PUBLIC $<BUILD_INTERFACE:${GRACKLE_GENRATED_PUBLIC_HEADERS}> # generated hdrs
         $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}> # hdrs in src directory

  # specify where to search for the other headers when linking against grackle
  # (for inclusion approach #2)
  INTERFACE $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)

# the following variable is an abbreviated shorthand used in "generator
# expressions" used to conditionally apply properties/compiler-flags to all
# source-code files the compose a build-target based on whether or not a given
# source-code file is written in Fortran
set(is_FC "$<COMPILE_LANGUAGE:Fortran>")

target_link_libraries(Grackle_Grackle
  PRIVATE GRACKLE_HDF5_C
          $<$<BOOL:${GRACKLE_USE_OPENMP}>:OpenMP::OpenMP_Fortran>
          $<$<BOOL:${GRACKLE_USE_OPENMP}>:OpenMP::OpenMP_C>
)

# add the necessary compiler-specific Fortran flags to ensure proper handling
# of our specific Fortran-dialect and that name mangling is performed as
# expected (these flags only get applied to Fortran source-code files)
include(AddConditionalFortranFlags)
add_conditional_fortran_flags(Grackle_Grackle)

# define macros so that the C files know how to properly handle name-mangling
# (if cmake were our only build-system, we could use FortranCInterface module)
if ("${CMAKE_SYSTEM_NAME}" MATCHES "^(Linux)|(Darwin)$")
  target_compile_definitions(Grackle_Grackle PRIVATE "LINUX")
endif()

# If we are building a shared library, construct a "configuration Makefile"
# that is used to build the code examples
# - we're mostly just doing this to let us run the code examples as part of the
#   pytest test suite (hence why we only do this for shared libraries)
if (BUILD_SHARED_LIBS)
  include(CreateExampleConfigMakefile)
  create_example_config_Makefile(
    "Make.examples-config" "Grackle::Grackle" "${GRACKLE_FC_FLAG}"
  )
endif()
