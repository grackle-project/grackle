# generate grackle_float.h AND auto_general.c
# ===========================================

# TODO: if they exist, delete ${CMAKE_CURRENT_SOURCE_DIR}/grackle_float.h AND
# ${CMAKE_CURRENT_SOURCE_DIR}/auto_general.c
# -> this probably isn't necessary, but it certainly makes things less confusing

# first, declare recipe for generating grackle_float.h:
if (GRACKLE_USE_DOUBLE)
  set(GRACKLE_FLOAT_MACRO "GRACKLE_FLOAT_8")
else()
  set(GRACKLE_FLOAT_MACRO "GRACKLE_FLOAT_4")
endif()
configure_file(../include/grackle_float.h.in
  ${GRACKLE_GENRATED_PUBLIC_HEADERS}/grackle_float.h @ONLY)

# next, declare recipe for generating auto_general.c:

# fetch necessary version information via query-version.py script
# -> GIT_BRANCH and GIT_REVISION hold sensible vals when git isn't installed
# -> VERSION_NUM may hold more information than Grackle_VERSION (e.g. like the
#    "dev" suffix)

set(_query_version "${CMAKE_CURRENT_SOURCE_DIR}/../../config/query_version.py")
function(query_version option OUTVAR)
  execute_process(
      COMMAND ${_query_version} ${option}
      RESULT_VARIABLE RSLT OUTPUT_VARIABLE OUT
      OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if(RSLT)
    message(FATAL_ERROR "Call to `${_query_version} ${option}` failed")
  endif()
  set(${OUTVAR} ${OUT} PARENT_SCOPE)
endfunction()

query_version(show-version VERSION_NUM)
query_version(git-branch GIT_BRANCH)
query_version(git-revision GIT_REVISION)

# in the original build-system, the following string also included things like:
# include-args, linking flags, macro definitions, all other compiler flags...
string(REPLACE "\n" "\\n" SHOW_FLAGS_STR "
  CC = ${CMAKE_C_COMPILER}
  FC = ${CMAKE_Fortran_COMPILER}
  LD = ${CMAKE_LINKER}
")

string(REPLACE "\n" "\\n" SHOW_CONFIG_STR "
   Built with CMake

   GRACKLE_USE_DOUBLE                  : ${GRACKLE_USE_DOUBLE}
   GRACKLE_USE_OPENMP                  : ${GRACKLE_USE_OPENMP}
   BUILD_TYPE                          : ${CMAKE_BUILD_TYPE}
")

configure_file(auto_general.c.in auto_general.c @ONLY)

# Declare the main target
# =======================

add_library(Grackle_Grackle

  # C source files
  calculate_cooling_time.c
  calculate_dust_temperature.c
  calculate_gamma.c
  calculate_pressure.c
  calculate_temperature.c
  dynamic_api.c
  grackle_units.c
  index_helper.c
  initialize_chemistry_data.c
  initialize_cloudy_data.c
  initialize_rates.c
  initialize_UVbackground_data.c
  rate_functions.c
  set_default_chemistry_parameters.c
  solve_chemistry.c
  update_UVbackground_rates.c
  calculate_cooling_time.c
  calculate_dust_temperature.c
  calculate_gamma.c
  calculate_pressure.c
  calculate_temperature.c
  dynamic_api.c
  grackle_units.c
  index_helper.c
  initialize_chemistry_data.c
  initialize_cloudy_data.c
  initialize_rates.c
  initialize_UVbackground_data.c
  rate_functions.c
  set_default_chemistry_parameters.c
  solve_chemistry.c
  update_UVbackground_rates.c
  calculate_cooling_time.c
  calculate_dust_temperature.c
  calculate_gamma.c
  calculate_pressure.c
  calculate_temperature.c
  dynamic_api.c
  grackle_units.c
  index_helper.c
  initialize_chemistry_data.c
  initialize_cloudy_data.c
  initialize_rates.c
  initialize_UVbackground_data.c
  rate_functions.c
  set_default_chemistry_parameters.c
  solve_chemistry.c
  update_UVbackground_rates.c
  utils.c

  # auto-generated C source files
  ${CMAKE_CURRENT_BINARY_DIR}/auto_general.c

  # Fortran Source Files
  calc_tdust_1d_g.F
  calc_tdust_3d_g.F
  calc_temp1d_cloudy_g.F
  calc_temp_cloudy_g.F
  cool1d_cloudy_g.F
  cool1d_cloudy_old_tables_g.F
  cool1d_multi_g.F
  cool_multi_time_g.F
  interpolators_g.F
  solve_rate_cool_g.F

  # explicitly list the autogenerated header(s)
  # -> If we don't explicitly list these (storing it in a list isn't adequate)
  #    a subtle bug can arise in the scenario when you are freshly building
  #    Grackle some after a previous build was installed in installed in a
  #    standard system location (like /usr/local)
  # -> In that scenario, CMake doesn't realize it needs to generate the
  #    header(s) because the compiler can finds versions of the headers from
  #    the prior build in the standard system location.
  ${GRACKLE_GENRATED_PUBLIC_HEADERS}/grackle_float.h

  # although not strictly necessary, listing out other header files is a "best
  # practice" (and is needed to make them show up in certain IDEs)

  # C/C++ public headers
  ../include/grackle.h
  ../include/grackle_chemistry_data.h
  ../include/grackle_rate_functions.h
  ../include/grackle_types.h

  # C private headers
  cie_thin_cooling_rate_tables.h
  grackle_chemistry_data_fields.def # <-- acts as a C header
  grackle_macros.h
  index_helper.h
  phys_constants.h
  utils.h

  # Fortran public headers
  ../include/grackle.def
  ../include/grackle_fortran_interface.def
  ../include/grackle_fortran_types.def

  # Fortran private headers
  phys_const.def
)

# A downstream application built with CMake generally has 2 inclusion
# approaches (ways that they can make use of this build):
#    1. they can build Grackle as part of the downstream build.
#       - in this case, the downstream build calls add_subdirectory on the top
#         level directory of Grackle and they can access the targets defined in
#         this file.
#    2. they can use the installed library
#       - in this case, the downstream build will get access to the targets
#         defined in a special CMake export-file created during installation
#
# We take some care to make these approaches as interchangable as possible for
# downstream build. To that end, we take 2 primary steps:
#
# - we name the main target Grackle_Grackle, rather than just [Gg]rackle to
#   minimize the chance for name-collisions of targets created by the build of
#   the downstream application (this is relevant for approach #1)
#
# - Following existing conventions, the downstream project should access the
#   target called Grackle::Grackle. We make use of a namespace to follow
#   convention... (they are more useful if we built multiple targets as part of
#   the build)
add_library(Grackle::Grackle ALIAS Grackle_Grackle) # for inclusion appraoch #1

# the logic diverges a little when naming the library
if (BUILD_SHARED_LIBS)
  # Because Grackle's API is not currently suited for ABI-compatability, we
  # take special steps when compiling it as a shared library (to reduce the
  # chance that an application linked against one version will try to load a
  # newer, incompatible version of the library)
  # - we take a page out of the existing build-system and libtool
  # - essentially, we will (i) encode the version in core-name of the library
  #   and (ii) make a symbolic link called libgrackle.so to the the library
  # - separate instructions are needed to make this link in build-directory
  #   and in the installation directory
  set(GRACKLE_LIB_OUTPUT_NAME "grackle-${VERSION_NUM}")
  add_custom_target(buildtree_link_target
    ALL COMMAND ${CMAKE_COMMAND} -E create_symlink
      $<TARGET_FILE:Grackle_Grackle>
      $<TARGET_FILE_DIR:Grackle_Grackle>/libgrackle$<TARGET_FILE_SUFFIX:Grackle_Grackle>)
else()
  set(GRACKLE_LIB_OUTPUT_NAME "grackle") # resulting lib is named libgrackle.a
endif()

# set standard cmake-specific properties
set_target_properties(Grackle_Grackle PROPERTIES
  OUTPUT_NAME ${GRACKLE_LIB_OUTPUT_NAME} # <- ensure library is properly named
  # specify target name that is made visible in inclusion approach #2. The
  # namespace-prefix of this target, "Grackle::", is declared in the
  # install(EXPORT ...) command included with the installation rules
  EXPORT_NAME Grackle

  # set custom properties (intended for consumption by downstream projects)
  # -> keep these in-sync with the properties in the Config-Package File
)

# write custom propeties used to convey information to downstream consumers
# of the Grackle library. To help us expose consistent information regardless
# of how Grackle is consume, we use this custom function that wraps
# set_target_properties (it's important to identify what is a BOOL vs STRING)
include(TargetInfoProps)
set_target_typed_info_properties(Grackle_Grackle STRING_PROPERTIES
  GRACKLE_VERSION_STR "${VERSION_NUM}"
)
set_target_typed_info_properties(Grackle_Grackle BOOL_PROPERTIES
  GRACKLE_USE_DOUBLE "${GRACKLE_USE_DOUBLE}"
  GRACKLE_USE_OPENMP "${GRACKLE_USE_OPENMP}"
)

target_include_directories(Grackle_Grackle
  # specify where to search for generated and ordinary headers when building
  # grackle AND when linking against grackle under inclusion approach #1
  # -> while it may seem unnecessary to specify the ordinary headers' directory
  #    while building grackle, it's necessary to compile auto_general.c
  PUBLIC $<BUILD_INTERFACE:${GRACKLE_GENRATED_PUBLIC_HEADERS}> # generated hdrs
         $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/../include> # public hdrs
         $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}> # private hdrs

  # specify where to search for the other headers when linking against grackle
  # (for inclusion approach #2)
  INTERFACE $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)

# the following variable is an abbreviated shorthand used in "generator
# expressions" used to conditionally apply properties/compiler-flags to all
# source-code files the compose a build-target based on whether or not a given
# source-code file is written in Fortran
set(is_FC "$<COMPILE_LANGUAGE:Fortran>")

target_link_libraries(Grackle_Grackle
  PRIVATE toolchain::m
          GRACKLE_HDF5_C
          $<$<BOOL:${GRACKLE_USE_OPENMP}>:OpenMP::OpenMP_Fortran>
          $<$<BOOL:${GRACKLE_USE_OPENMP}>:OpenMP::OpenMP_C>
)

# add the necessary compiler-specific Fortran flags to ensure proper handling
# of our specific Fortran-dialect and that name mangling is performed as
# expected (these flags only get applied to Fortran source-code files)
include(AddConditionalFortranFlags)
add_conditional_fortran_flags(Grackle_Grackle)

# define macros so that the C files know how to properly handle name-mangling
# (if cmake were our only build-system, we could use FortranCInterface module)
if ("${CMAKE_SYSTEM_NAME}" MATCHES "^(Linux)|(Darwin)$")
  target_compile_definitions(Grackle_Grackle PRIVATE "LINUX")
endif()

# If we are building a shared library, construct a "configuration Makefile"
# that is used to build the code examples
# - we're mostly just doing this to let us run the code examples as part of the
#   pytest test suite (hence why we only do this for shared libraries)
if (BUILD_SHARED_LIBS)
  include(CreateExampleConfigMakefile)
  create_example_config_Makefile(
    "Make.examples-config" "Grackle::Grackle" "${GRACKLE_FC_FLAG}"
  )
endif()
